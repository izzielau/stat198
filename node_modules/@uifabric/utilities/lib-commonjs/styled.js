"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var merge_styles_1 = require("@uifabric/merge-styles");
var Customizations_1 = require("./customizations/Customizations");
var CustomizerContext_1 = require("./customizations/CustomizerContext");
var DefaultFields = ['theme', 'styles'];
function useForceUpdate() {
    var _a = React.useReducer(function (state) { return state + 1; }, 0), reducer = _a[1];
    return function () { return reducer(null); };
}
function styled(Component, baseStyles, getProps, customizable, pure) {
    customizable = customizable || { scope: '', fields: undefined };
    var scope = customizable.scope, _a = customizable.fields, fields = _a === void 0 ? DefaultFields : _a;
    var Wrapped = React.forwardRef(function (props, forwardedRef) {
        var styles = React.useRef();
        var forceUpdate = useForceUpdate();
        var context = React.useContext(CustomizerContext_1.CustomizerContext);
        React.useEffect(function () {
            if (!context.customizations.inCustomizerContext) {
                Customizations_1.Customizations.observe(forceUpdate);
                return function () { return Customizations_1.Customizations.unobserve(forceUpdate); };
            }
        }, []);
        var settings = Customizations_1.Customizations.getSettings(fields, scope, context.customizations);
        var customizedStyles = settings.styles, dir = settings.dir, rest = tslib_1.__rest(settings, ["styles", "dir"]);
        var additionalProps = getProps ? getProps(props) : undefined;
        // tslint:disable-next-line:no-any
        var cache = (styles.current && styles.current.__cachedInputs__) || [];
        if (!styles.current || customizedStyles !== cache[1] || props.styles !== cache[2]) {
            // Using styled components as the Component arg will result in nested styling arrays.
            var concatenatedStyles = function (styleProps) {
                return merge_styles_1.concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, props.styles);
            };
            // The __cachedInputs__ array is attached to the function and consumed by the
            // classNamesFunction as a list of keys to include for memoizing classnames.
            concatenatedStyles.__cachedInputs__ = [
                baseStyles,
                customizedStyles,
                props.styles,
            ];
            concatenatedStyles.__noStyleOverride__ =
                !customizedStyles && !props.styles;
            styles.current = concatenatedStyles;
        }
        return React.createElement(Component, tslib_1.__assign({ ref: forwardedRef }, rest, additionalProps, props, { styles: styles.current }));
    });
    // Function.prototype.name is an ES6 feature, so the cast to any is required until we're
    // able to drop IE 11 support and compile with ES6 libs
    // tslint:disable-next-line:no-any
    Wrapped.displayName = "Styled" + (Component.displayName || Component.name);
    // This preserves backwards compatibility.
    return pure ? React.memo(Wrapped) : Wrapped;
}
exports.styled = styled;
//# sourceMappingURL=styled.js.map