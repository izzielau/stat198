import { Async } from '@uifabric/utilities';
import * as React from 'react';
import { Ref } from 'react';

export declare type ChangeCallback<TElement extends HTMLElement, TValue> = (ev: React.FormEvent<TElement> | undefined, newValue: TValue | undefined) => void;

/** Updater callbacks returned by `useBoolean`. */
export declare interface IUseBooleanCallbacks {
    /** Set the value to true. Always has the same identity. */
    setTrue: () => void;
    /** Set the value to false. Always has the same identity. */
    setFalse: () => void;
    /** Toggle the value. Always has the same identity. */
    toggle: () => void;
}

/**
 * Hook to provide an Async instance that is automatically cleaned up on dismount.
 */
export declare function useAsync(): Async;

/**
 * Hook to store a value and generate callbacks for setting the value to true or false.
 * The identity of the callbacks will always stay the same.
 *
 * @param initialState - Initial value
 * @returns Array with the current value and an object containing the updater callbacks.
 */
export declare function useBoolean(initialState: boolean): [boolean, IUseBooleanCallbacks];

/**
 * Hook to initialize and return a constant value. Unlike `React.useMemo`, this is guaranteed to
 * always return the same value (and if the initializer is a function, only call it once).
 * This is similar to setting a private member in a class constructor.
 *
 * If the value should ever change based on dependencies, use `React.useMemo` instead.
 *
 * If the value itself is a function, consider using `useConstCallback` instead.
 *
 * @param initialValue - Initial value, or function to get the initial value. Similar to `useState`,
 * only the value/function passed in the first time this is called is respected.
 * @returns The value. The identity of this value will always be the same.
 */
export declare function useConst<T>(initialValue: T | (() => T)): T;

/**
 * Hook to ensure a callback function always has the same identity.
 * Unlike `React.useCallback`, this is guaranteed to always return the same value.
 *
 * If the callback should ever change based on dependencies, use `React.useCallback` instead.
 *
 * @param callback - The callback. Only the first value passed is respected.
 * @returns The callback. The identity of this callback will always be the same.
 */
export declare function useConstCallback<T extends (...args: any[]) => any>(callback: T): T;

/**
 * Hook to manage a value that could be either controlled or uncontrolled, such as a checked state or
 * text box string.
 * @param controlledValue- The controlled value passed in the props. This value will always be used if provided, and the
 * internal state will be updated to reflect it.
 * @param defaultUncontrolledValue- Initial value for the internal state in the uncontrolled case.
 * @see https://reactjs.org/docs/uncontrolled-components.html
 */
export declare function useControllableValue<TValue, TElement extends HTMLElement>(controlledValue: TValue | undefined, defaultUncontrolledValue: TValue | undefined): Readonly<[TValue | undefined, (newValue: TValue | undefined) => void]>;

export declare function useControllableValue<TValue, TElement extends HTMLElement, TCallback extends ChangeCallback<TElement, TValue> | undefined>(controlledValue: TValue | undefined, defaultUncontrolledValue: TValue | undefined, onChange: TCallback): Readonly<[TValue | undefined, (newValue: TValue | undefined, ev?: React.FormEvent<TElement>) => void]>;

/**
 * Hook to force update a function component by updating a dummy state.
 */
export declare function useForceUpdate(): () => void;

/**
 * Hook to generate a unique ID in the global scope (spanning across duplicate copies of the same library).
 *
 * @param prefix - Optional prefix for the ID
 * @param providedId - Optional id provided by a parent component. Defaults to the provided value if present,
 *  without conditioning the hook call
 * @returns The ID
 */
export declare function useId(prefix?: string, providedId?: string): string;

/**
 * React hook to merge multiple React refs (either MutableRefObjects or ref callbacks) into a single ref callback that
 * updates all provided refs
 * @param refs- Refs to collectively update with one ref value.
 */
export declare function useMergedRefs<T>(...refs: Ref<T>[]): (instance: T) => void;

/**
 * Hook to attach an event handler on mount and handle cleanup.
 * @param element- Element (or ref to an element) to attach the event handler to
 * @param eventName- The event to attach a handler for
 * @param callback- The handler for the event
 * @param useCapture- Whether or not to attach the handler for the capture phase
 */
export declare function useOnEvent<TElement extends Element, TEvent extends Event>(element: React.RefObject<TElement | undefined | null> | TElement | Window | undefined | null, eventName: string, callback: (ev: TEvent) => void, useCapture?: boolean): void;

/**
 * Hook keeping track of a given value from a previous execution of the component the Hook is used in.
 *
 * See [React Hooks FAQ](https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state)
 */
export declare function usePrevious<T>(value: T): T | undefined;

export { }
